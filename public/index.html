<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Landing</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.jsdelivr.net/npm/@fingerprintjs/fingerprintjs@3.4.0/dist/fp.min.js"></script>
</head>
<body>
<script>

  // fingerprint.js

// Convierte ArrayBuffer (hash) a string hexadecimal
function bufferToHex(buffer) {
  const bytes = new Uint8Array(buffer);
  let hex = '';
  for (let i = 0; i < bytes.length; i++) {
    const current = bytes[i].toString(16).padStart(2, '0');
    hex += current;
  }
  return hex;
}

// Comprueba si localStorage está disponible (sin romperse por restricciones)
function hasLocalStorage() {
  try {
    const key = '__fp_test_ls__';
    window.localStorage.setItem(key, '1');
    window.localStorage.removeItem(key);
    return 1;
  } catch (e) {
    return 0;
  }
}

// Igual para sessionStorage
function hasSessionStorage() {
  try {
    const key = '__fp_test_ss__';
    window.sessionStorage.setItem(key, '1');
    window.sessionStorage.removeItem(key);
    return 1;
  } catch (e) {
    return 0;
  }
}

// Recoge SOLO datos muy básicos, presentes siempre en móvil
function getFingerprintComponents() {
  const nav = (typeof navigator !== 'undefined') ? navigator : {};
  const scr = (typeof screen !== 'undefined') ? screen : {};
  const hasIntl = typeof Intl !== 'undefined' && typeof Intl.DateTimeFormat === 'function';

  let timeZone = '';
  try {
    if (hasIntl) {
      const opts = Intl.DateTimeFormat().resolvedOptions();
      timeZone = opts.timeZone || '';
    }
  } catch (e) {
    timeZone = '';
  }

  return {
    // Navegador / SO
    userAgent: nav.userAgent || '',
    platform: nav.platform || '',
    language: nav.language || '',
    languages: Array.isArray(nav.languages) ? nav.languages.join(',') : '',
    maxTouchPoints: nav.maxTouchPoints || 0,

    // Pantalla
    screenWidth: scr.width || 0,
    screenHeight: scr.height || 0,
    availWidth: scr.availWidth || 0,
    availHeight: scr.availHeight || 0,
    colorDepth: scr.colorDepth || 0,
    pixelRatio: typeof window !== 'undefined' && window.devicePixelRatio ? window.devicePixelRatio : 1,

    // Zona horaria / fecha
    timezoneOffset: new Date().getTimezoneOffset(),
    timeZone,

    // Capacidades de navegador
    cookieEnabled: nav.cookieEnabled ? 1 : 0,
    doNotTrack: nav.doNotTrack || '',
    localStorage: hasLocalStorage(),
    sessionStorage: hasSessionStorage()
  };
}

// Normaliza los datos y genera un string determinista
function buildCanonicalString(components) {
  const keys = Object.keys(components).sort(); // orden fijo
  return keys
    .map(k => `${k}:${String(components[k])}`)
    .join('|');
}

// Fingerprint final: SHA-256 del string canónico (hex)
async function getDeviceFingerprint() {
  if (typeof window === 'undefined' || typeof navigator === 'undefined') {
    throw new Error('Fingerprint solo puede calcularse en el navegador.');
  }

  const components = getFingerprintComponents();
  const canonical = buildCanonicalString(components);

  if (!window.crypto || !window.crypto.subtle) {
    // Fallback muy simple si no hay Web Crypto (raro en móviles modernos)
    // Ojo: menos seguro / único, pero mantiene coherencia.
    let hash = 0;
    for (let i = 0; i < canonical.length; i++) {
      hash = ((hash << 5) - hash) + canonical.charCodeAt(i);
      hash |= 0;
    }
    return `fallback_${hash}`;
  }

  const encoder = new TextEncoder();
  const data = encoder.encode(canonical);
  const digest = await window.crypto.subtle.digest('SHA-256', data);
  console.log('Canonical string for fingerprint:', digest);
  return bufferToHex(digest);
}

(async function() {
  const PLAY_URL = 'https://google.com';//https://play.google.com/store/apps/details?id=com.cognifit.app';

  function redirectToAppOrStore(token) {
    return;
    const ua = navigator.userAgent || '';
    const isAndroid = /Android/i.test(ua);
    const isChrome = /Chrome/i.test(ua);
    const intentUrl =
      `intent://open?ctx=${encodeURIComponent(token)}#Intent;scheme=myapp;package=com.tuapp;end`;

    // Solo intent en Chrome Android
    if (false && isAndroid && isChrome) {
      const start = Date.now();
      // Intent: si la app está instalada, se abre y JS “muere” ahí
      window.location.href = intentUrl;

      // Fallback: si seguimos en la página 1.5–2s después, vamos a Play Store
      setTimeout(() => {
        const elapsed = Date.now() - start;
        if (elapsed < 2000) {
          // Probablemente no había handler / app instalada
          window.location.href = PLAY_URL;
        }
      }, 1500);
    } else {
      // Escritorio, iOS, otros navegadores → directo a Play Store
      window.location.href = PLAY_URL;
    }
  }

  const ts_click = Date.now();
  const payload = {
    ua_js: navigator.userAgent,
    language: navigator.language,
    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
    innerW: window.innerWidth,
    innerH: window.innerHeight,
    screenW: screen.width,
    screenH: screen.height,
    dpr: window.devicePixelRatio,
    ts_click
  };

  try {
    const result = await getDeviceFingerprint();
    console.log('[Landing] device fingerprint:', result);
    payload.fp_id = result;
  } catch(e){}

  try {
      console.log('[Landing] visitorId:', payload.fp_id);
      const res = await fetch('/api/click', {
      method: 'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify({campaign:'android', payload})
    });

    if (!res.ok) {
      console.error('API /click no OK', res.status, res.statusText);
      redirectToAppOrStore(null); // aún así redirigimos
      return;
    }

    const { token } = await res.json();
    redirectToAppOrStore(token);
  } catch(e){
    console.error('Error en fetch /api/click:', e);
    // Si falla la API, igualmente mandamos al Play Store / app
    redirectToAppOrStore(null);
  }
})();
</script>

</body>
</html>
